<!doctype html><html lang=en><head><meta charset=utf-8><title>How to use NixOS testing framework with flakes | ~/git/blog</title><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jörg Thalheim and Alex A. Renoire"><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><script data-goatcounter=https://goatcounter.thalheim.io/count async src=https://goatcounter.thalheim.io/count.js></script><meta property="og:title" content="How to use NixOS testing framework with flakes"><meta property="og:description" content="In this article, I will explain how to perform full integration tests with flakes outside nixpkgs.
With NixOS testing framework, you can create end-to-end integration tests easily. It all comes down to starting a virtual machine based on your custom modules and testing its state with a Python script. This way, you can identify in advance all the regressions and incompatible configurations arising from the updates you introduced.
One of the framework&rsquo;s upsides is that it&rsquo;s extremely fast — maybe the fastest of its kind: setting up VMs and running tests does not take much time thanks to sharing files with the nix store on the host."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thalheim.io/2023/01/08/how-to-use-nixos-testing-framework-with-flakes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-08T11:46:06+01:00"><meta property="article:modified_time" content="2023-01-08T11:46:06+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to use NixOS testing framework with flakes"><meta name=twitter:description content="In this article, I will explain how to perform full integration tests with flakes outside nixpkgs.
With NixOS testing framework, you can create end-to-end integration tests easily. It all comes down to starting a virtual machine based on your custom modules and testing its state with a Python script. This way, you can identify in advance all the regressions and incompatible configurations arising from the updates you introduced.
One of the framework&rsquo;s upsides is that it&rsquo;s extremely fast — maybe the fastest of its kind: setting up VMs and running tests does not take much time thanks to sharing files with the nix store on the host."><meta itemprop=name content="How to use NixOS testing framework with flakes"><meta itemprop=description content="In this article, I will explain how to perform full integration tests with flakes outside nixpkgs.
With NixOS testing framework, you can create end-to-end integration tests easily. It all comes down to starting a virtual machine based on your custom modules and testing its state with a Python script. This way, you can identify in advance all the regressions and incompatible configurations arising from the updates you introduced.
One of the framework&rsquo;s upsides is that it&rsquo;s extremely fast — maybe the fastest of its kind: setting up VMs and running tests does not take much time thanks to sharing files with the nix store on the host."><meta itemprop=datePublished content="2023-01-08T11:46:06+01:00"><meta itemprop=dateModified content="2023-01-08T11:46:06+01:00"><meta itemprop=wordCount content="1374"><meta itemprop=keywords content></head><body><header><div id=titletext><h2 id=title><a href=https://blog.thalheim.io/>~/git/blog</a></h2></div><div id=title-description><p id=subtitle>My brain-dump of random code/configuration.</p><div id=social><nav><ul><li><a href=/index.xml rel=me aria-label=RSS><span title=RSS class="icons fas fa-rss" aria-hidden=true></span></a></li><li><a href=https://github.com/Mic92/blog rel=me aria-label=Github><span title=Github class="icons fab fa-github" aria-hidden=true></span></a></li><li><button id=dark-mode aria-label="Switch Dark Mode"><span title="Switch Dark Mode" class="icons fas fa-moon" aria-hidden=true></span></button></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>All Posts</a></li><li><a href=/categories>Categories</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>08</span>
<span class=rest>Jan 2023</span></div></div><div class=matter><h1 class=title>How to use NixOS testing framework with flakes</h1><p class=post-meta><span class=post-meta><span aria-label=Author:><span class="fas fa-user" aria-hidden=true></span></span>&nbsp;
Jörg Thalheim and Alex A. Renoire</span></p></div></div><div class=markdown><p>In this article, I will explain how to perform full integration tests with
flakes outside nixpkgs.</p><p>With <a href=https://wiki.nixos.org/wiki/NixOS_Testing_library target=_blank>NixOS testing framework</a>,
you can
<a href=https://nix.dev/tutorials/integration-testing-using-virtual-machines target=_blank>create end-to-end integration tests</a>
easily. It all comes down to starting a virtual machine based on your custom
modules and testing its state with a Python script. This way, you can identify
in advance all the regressions and incompatible configurations arising from the
updates you introduced.</p><p>One of the framework&rsquo;s upsides is that it&rsquo;s extremely fast — maybe the fastest
of its kind: setting up VMs and running tests does not take much time thanks to
sharing files with the nix store on the host.</p><p>But previously, there was no stable API to import the testing framework into
projects, therefore it was hard to test anything that&rsquo;s outside NixOS. The
situation has changed thanks to Robert Hensing, who [created a new modular
interface] for testing.</p><p>But there&rsquo;s still a problem with documentation. Of course, you can refer to the
corresponding
<a href=https://github.com/NixOS/nixpkgs/blob/master/nixos/doc/manual/development/writing-nixos-tests.section.md target=_blank>manual chapter</a>
to explore NixOS testing framework. But many topics aren&rsquo;t explained in detail,
so I decided to write a brief intro to testing NixOS modules with flakes.</p><h1 id=intro-to-testing-in-nixos>Intro to testing in NixOS</h1><p>Let me give you some info on how tests are executed, and how to incorporate them
into your project. If you&rsquo;re new to NixOS, this info may be helpful.</p><p>So, how are tests executed in NixOS? To verify that the flake can be evaluated
successfully, we run the
<a href=https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake-check.html target=_blank>flake check</a>
command. Under the hood, nix will run the so-called test driver in its own build
sandbox. The test driver provides an API for the test script to setup virtual
machines. When the VMs are ready, a series of tests are executed to check if
NixOS modules are functioning as intended.</p><p>That&rsquo;s a very broad outlook on how tests work. But how do you write tests?
First, if you are testing a module outside NixOS, i.e. in your own project, you
have to import <code>nixpkgs</code>, the biggest repository of Nix packages where the
testing library is located.</p><p>There are several ways to import <code>nixpkgs</code> in your code. One way is via
<code>fetchTarball</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span>{
</span></span><span style=display:flex><span>  nixpkgs <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>fetchTarball</span> <span style=color:#f1fa8c>&#34;https://github.com/NixOS/nixpkgs/archive/....tar.gz&#34;</span>;
</span></span><span style=display:flex><span>  pkgs <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> nixpkgs {};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But <code>fetchTarball</code> is a builtin, which means that <code>nixpkgs</code> will be downloaded
during evaluation. Another way is to load <code>nixpkgs</code> using a
<a href=https://wiki.nixos.org/wiki/Flakes target=_blank>flake</a>. It&rsquo;s more convenient, because this way
you can update the dependencies easily. I&rsquo;ll use this approach in my example.</p><p>Let&rsquo;s move to the coding part now.</p><h1 id=defining-a-flake-to-be-tested>Defining a flake to be tested</h1><p>As an example, I’ll take a simple project that runs a web server returning a
“Hello world!” string. First, let’s specify the flake:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#6272a4># flake.nix</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  inputs<span style=color:#ff79c6>.</span>nixpkgs<span style=color:#ff79c6>.</span>url <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;github:nixos/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span style=display:flex><span>  outputs <span style=color:#ff79c6>=</span> { self<span style=color:#ff79c6>,</span> nixpkgs<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>...</span>}: {
</span></span><span style=display:flex><span>    nixosModules<span style=color:#ff79c6>.</span>hello-world-server <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./hello-world-server.nix</span> {};
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This flake exposes the module <code>./hello-world-server.nix</code>. You can find the file
in the repository <a href=https://github.com/Mic92/nixos-test-example target=_blank>here</a>. What it
does is it creates a simple HTML page and starts a server on the port 8000. The
correct behavior would be if the module returns a “Hello world!” string. Any
other output will be incorrect.</p><h1 id=writing-the-tests>Writing the tests</h1><p>Now that we have our flake and module, we can write a test to check if we can
reach the server.</p><p>But before that, we will create a helper function in <code>./tests/lib.nix</code>, which
will import the testing framework from nixpkgs. Extending <code>specialArgs</code> will
allow us to pass through any flake inputs and outputs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#6272a4># tests/lib.nix</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># The first argument to this function is the test module itself</span>
</span></span><span style=display:flex><span>test:
</span></span><span style=display:flex><span><span style=color:#6272a4># These arguments are provided by `flake.nix` on import, see checkArgs</span>
</span></span><span style=display:flex><span>{ pkgs<span style=color:#ff79c6>,</span> self}:
</span></span><span style=display:flex><span><span style=color:#ff79c6>let</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>inherit</span> (pkgs) lib;
</span></span><span style=display:flex><span>  <span style=color:#6272a4># this imports the nixos library that contains our testing framework</span>
</span></span><span style=display:flex><span>  nixos-lib <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> (pkgs<span style=color:#ff79c6>.</span>path <span style=color:#ff79c6>+</span> <span style=color:#f1fa8c>&#34;/nixos/lib&#34;</span>) {};
</span></span><span style=display:flex><span><span style=color:#ff79c6>in</span>
</span></span><span style=display:flex><span>(nixos-lib<span style=color:#ff79c6>.</span>runTest {
</span></span><span style=display:flex><span>  hostPkgs <span style=color:#ff79c6>=</span> pkgs;
</span></span><span style=display:flex><span>  <span style=color:#6272a4># This speeds up the evaluation by skipping evaluating documentation (optional)</span>
</span></span><span style=display:flex><span>  defaults<span style=color:#ff79c6>.</span>documentation<span style=color:#ff79c6>.</span>enable <span style=color:#ff79c6>=</span> lib<span style=color:#ff79c6>.</span>mkDefault false;
</span></span><span style=display:flex><span>  <span style=color:#6272a4># This makes `self` available in the NixOS configuration of our virtual machines.</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4># This is useful for referencing modules or packages from your own flake</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4># as well as importing from other flakes.</span>
</span></span><span style=display:flex><span>  node<span style=color:#ff79c6>.</span>specialArgs <span style=color:#ff79c6>=</span> { <span style=color:#ff79c6>inherit</span> self; };
</span></span><span style=display:flex><span>  imports <span style=color:#ff79c6>=</span> [ test ];
</span></span><span style=display:flex><span>})<span style=color:#ff79c6>.</span>config<span style=color:#ff79c6>.</span>result
</span></span></code></pre></div><p>You can use this helper function across different NixOS tests in your project.</p><p>Now, let’s create the test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#6272a4># ./tests/hello-world-server.nix</span>
</span></span><span style=display:flex><span>(<span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./lib.nix</span>) {
</span></span><span style=display:flex><span>  name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;from-nixos&#34;</span>;
</span></span><span style=display:flex><span>  nodes <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#6272a4># `self` here is set by using specialArgs in `lib.nix`</span>
</span></span><span style=display:flex><span>    node1 <span style=color:#ff79c6>=</span> { self<span style=color:#ff79c6>,</span> pkgs<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>...</span> }: {
</span></span><span style=display:flex><span>      imports <span style=color:#ff79c6>=</span> [ self<span style=color:#ff79c6>.</span>nixosModules<span style=color:#ff79c6>.</span>hello-world-server ];
</span></span><span style=display:flex><span>      environment<span style=color:#ff79c6>.</span>systemPackages <span style=color:#ff79c6>=</span> [ pkgs<span style=color:#ff79c6>.</span>curl ];
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#6272a4># This is the test code that will check if our service is running correctly:</span>
</span></span><span style=display:flex><span>  testScript <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    start_all()
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    # wait for our service to start
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    node1.wait_for_unit(&#34;hello-world-server&#34;)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    node1.wait_for_open_port(8000)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    output = node1.succeed(&#34;curl localhost:8000/index.html&#34;)
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    # Check if our webserver returns the expected result
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    assert &#34;Hello world&#34; in output, f&#34;&#39;{output}&#39; does not contain &#39;Hello world&#39;&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>  &#39;&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To expose the test in our flake, we will import it in the checks output in the
<code>flake.nix</code> file. This will make the test run when you execute the
<code>nix flake check -L</code> command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#6272a4># flake.nix</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  inputs<span style=color:#ff79c6>.</span>nixpkgs<span style=color:#ff79c6>.</span>url <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;github:nixos/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span style=display:flex><span>  outputs <span style=color:#ff79c6>=</span> { self<span style=color:#ff79c6>,</span> nixpkgs<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>...</span>}: <span style=color:#ff79c6>let</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># expose systems for `x86_64-linux` and `aarch64-linux`</span>
</span></span><span style=display:flex><span>    forAllSystems <span style=color:#ff79c6>=</span> nixpkgs<span style=color:#ff79c6>.</span>lib<span style=color:#ff79c6>.</span>genAttrs [ <span style=color:#f1fa8c>&#34;x86_64-linux&#34;</span> <span style=color:#f1fa8c>&#34;aarch64-linux&#34;</span> ];
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>in</span> {
</span></span><span style=display:flex><span>    nixosModules<span style=color:#ff79c6>.</span>hello-world-server <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./hello-world-server.nix</span>;
</span></span><span style=display:flex><span>    checks <span style=color:#ff79c6>=</span> forAllSystems (system: <span style=color:#ff79c6>let</span>
</span></span><span style=display:flex><span>      checkArgs <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4># reference to nixpkgs for the current system</span>
</span></span><span style=display:flex><span>        pkgs <span style=color:#ff79c6>=</span> nixpkgs<span style=color:#ff79c6>.</span>legacyPackages<span style=color:#ff79c6>.</span><span style=color:#f1fa8c>${</span>system<span style=color:#f1fa8c>}</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4># this gives us a reference to our flake but also all flake inputs</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>inherit</span> self;
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>in</span> {
</span></span><span style=display:flex><span>      <span style=color:#6272a4># import our test</span>
</span></span><span style=display:flex><span>      hello-world-server <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./tests/hello-world-server.nix</span> checkArgs;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have our nixos module, we can write a nixos test to check if we can
reach the &ldquo;hello world&rdquo; application. To expose the test in our flake, we will
add an attribute under the <code>checks</code> output in the <code>flake.nix</code> file. This will
make the test run when you execute the <code>nix flake check -L</code> command. The test
uses the hello-world-server nixos module and checks if the application can be
reached.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=display:flex><span><span style=color:#6272a4># flake.nix</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  inputs<span style=color:#ff79c6>.</span>nixpkgs<span style=color:#ff79c6>.</span>url <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;github:nixos/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span style=display:flex><span>  outputs <span style=color:#ff79c6>=</span> { self<span style=color:#ff79c6>,</span> nixpkgs<span style=color:#ff79c6>,</span> <span style=color:#ff79c6>...</span>}: <span style=color:#ff79c6>let</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># expose systems for `x86_64-linux` and `aarch64-linux`</span>
</span></span><span style=display:flex><span>    forAllSystems <span style=color:#ff79c6>=</span> nixpkgs<span style=color:#ff79c6>.</span>lib<span style=color:#ff79c6>.</span>genAttrs [ <span style=color:#f1fa8c>&#34;x86_64-linux&#34;</span> <span style=color:#f1fa8c>&#34;aarch64-linux&#34;</span> ];
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>in</span> {
</span></span><span style=display:flex><span>    nixosModules<span style=color:#ff79c6>.</span>hello-world-server <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./hello-world-server.nix</span>;
</span></span><span style=display:flex><span>    checks <span style=color:#ff79c6>=</span> forAllSystems (system: <span style=color:#ff79c6>let</span>
</span></span><span style=display:flex><span>      checkArgs <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4># reference to nixpkgs for the current system</span>
</span></span><span style=display:flex><span>        pkgs <span style=color:#ff79c6>=</span> nixpkgs<span style=color:#ff79c6>.</span>legacyPackages<span style=color:#ff79c6>.</span><span style=color:#f1fa8c>${</span>system<span style=color:#f1fa8c>}</span>;
</span></span><span style=display:flex><span>        <span style=color:#6272a4># this gives us a reference to our flake but also all flake inputs</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>inherit</span> self;
</span></span><span style=display:flex><span>      };
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>in</span> {
</span></span><span style=display:flex><span>      <span style=color:#6272a4># import our test</span>
</span></span><span style=display:flex><span>      hello-world-server <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>./tests/hello-world-server.nix</span> checkArgs;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=running-the-tests>Running the tests</h1><p>To verify that everything works as expected, run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span>$ nix flake check -L
</span></span></code></pre></div><p>The -L parameter here tells the testing framework to print all logs that occur
during the test, making it easier to follow.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#44475a>start all VLans
</span></span></span><span style=display:flex><span><span style=color:#44475a>...
</span></span></span><span style=display:flex><span><span style=color:#44475a>start all VMs
</span></span></span><span style=display:flex><span><span style=color:#44475a>...
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1: waiting for unit hello-world-server
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1: waiting for the VM to finish booting
</span></span></span><span style=display:flex><span><span style=color:#44475a>...
</span></span></span><span style=display:flex><span><span style=color:#44475a>(finished: waiting for unit hello-world-server, in 7.02 seconds)
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1: must succeed: curl localhost:8000/index.html
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1 #   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1 #                                  Dload  Upload   Total   Spent    Left  Speed
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1 #   0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0[    6.668081] hello-world-server[824]: 127.0.0.1 - - [08/Jan/2023 19:59:47] &#34;GET /index.html HTTP/1
</span></span></span><span style=display:flex><span><span style=color:#44475a>.1&#34; 200 -
</span></span></span><span style=display:flex><span><span style=color:#44475a>node1 # 100    87  100    87    0     0   4034      0 --:--:-- --:--:-- --:--:--  4350
</span></span></span><span style=display:flex><span><span style=color:#44475a>(finished: must succeed: curl localhost:8000/index.html, in 0.07 seconds)
</span></span></span><span style=display:flex><span><span style=color:#44475a>(finished: run the VM test script, in 7.15 seconds)
</span></span></span><span style=display:flex><span><span style=color:#44475a>test script finished in 7.18s
</span></span></span><span style=display:flex><span><span style=color:#44475a>...
</span></span></span></code></pre></div><p>Here, the testing framework creates a virtual network and a virtual machine with
our module in it, then it waits for the hello-world-server to start and checks
if its output is valid. Here, the output is “Hello world!”, so we passed the
test.</p><p>Now our hello-world-server NixOS module has a proper test!</p><h1 id=conclusion>Conclusion</h1><p>In this article, we explained how you can leverage the NixOS testing framework
for your projects while importing the nixpkgs repository. In particular, we
defined a NixOS test in a flake and exposed it through the checks output, making
it run when executing the <code>nix flake check -L</code> command.</p><p>But often you need to run your tests interactively to check the debug output and
gain more insight into why a test isn’t behaving the way you expected. That’s
what I explore in a <a href=https://blog.thalheim.io/2023/01/08/how-to-execute-nixos-tests-interactively-for-debugging/>twin article</a>.</p></div><div class=tags><div class=taxosfloating_left><p>Categories</p></div><div class=termsfloating_right><p><a href=/categories/nixos/>nixos</a></p></div><div class=clearit></div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mic92.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></div></main><footer>© 2021 Jörg Thalheim</footer><script src=/js/dark-mode.js></script></body></html>