<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta property="og:title" content="Cgi Like Python Scripts With Systemd Socket Activation"><meta property="og:title" content="Cgi Like Python Scripts With Systemd Socket Activation"><meta property="og:description" content="Lets say you want to trigger remote the start of a python script. But you don&rsquo;t want to have a service running all the time waiting for requests.
What you can do, is using socket-unit in systemd, which is waiting on a tcp port for connections and starts the service, if somebody is requesting it.
The systemd configuration could look like this:
 Listens on tcp port 3000 (both ipv4 and ipv6) Execute python script as user &lsquo;nobody&rsquo; with a timeout of 5 minutes  [Unit] Description=Start update on demand [Socket] ListenStream=3000 # only listen on localhost #ListenStream=127."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thalheim.io/2015/06/25/cgi-like-python-scripts-with-systemd-socket-activation/"><meta property="article:published_time" content="2015-06-25T00:00:00+00:00"><meta property="article:modified_time" content="2015-06-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cgi Like Python Scripts With Systemd Socket Activation"><meta name=twitter:description content="Lets say you want to trigger remote the start of a python script. But you don&rsquo;t want to have a service running all the time waiting for requests.
What you can do, is using socket-unit in systemd, which is waiting on a tcp port for connections and starts the service, if somebody is requesting it.
The systemd configuration could look like this:
 Listens on tcp port 3000 (both ipv4 and ipv6) Execute python script as user &lsquo;nobody&rsquo; with a timeout of 5 minutes  [Unit] Description=Start update on demand [Socket] ListenStream=3000 # only listen on localhost #ListenStream=127."><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><title>Cgi Like Python Scripts With Systemd Socket Activation | ~/git/blog</title><script data-goatcounter=https://goatcounter.thalheim.io/count async src=https://goatcounter.thalheim.io/count.js></script></head><body><header><div id=titletext><h2 id=title><a href=https://blog.thalheim.io/>~/git/blog</a></h2></div><div id=title-description><p id=subtitle>My brain-dump of random code/configuration.</p><div id=social><nav><ul><li><a href=/index.xml><i title=RSS class="icons fas fa-rss"></i></a></li><li><a href=https://github.com/Mic92/blog><i title=Github class="icons fab fa-github"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/post>All Posts</a></li><li><a href=/categories>Categories</a></li></ul></nav></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>25</span>
<span class=rest>Jun 2015</span></div></div><div class=matter><h1 class=title>Cgi Like Python Scripts With Systemd Socket Activation</h1></div></div><div class=markdown><p>Lets say you want to trigger remote the start of a python script.
But you don&rsquo;t want to have a service running all the time waiting for requests.</p><p>What you can do, is using socket-unit in systemd, which is waiting on a tcp port for connections
and starts the service, if somebody is requesting it.</p><p>The systemd configuration could look like this:</p><ul><li>Listens on tcp port 3000 (both ipv4 and ipv6)</li><li>Execute python script as user &lsquo;nobody&rsquo; with a timeout of 5 minutes</li></ul><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemd data-lang=systemd><span style=color:#000;font-weight:700>[Unit]</span>
<span style=color:teal>Description</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>Start update on demand</span>

<span style=color:#000;font-weight:700>[Socket]</span>
<span style=color:teal>ListenStream</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>3000</span>
<span style=color:#998;font-style:italic># only listen on localhost</span>
<span style=color:#998;font-style:italic>#ListenStream=127.0.0.1:3000</span>
<span style=color:teal>BindIPv6Only</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>both</span>

<span style=color:#000;font-weight:700>[Install]</span>
<span style=color:teal>WantedBy</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>multi-user.target</span>
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-systemd data-lang=systemd><span style=color:#000;font-weight:700>[Unit]</span>
<span style=color:teal>Description</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>Start update on demand</span>
<span style=color:teal>JobTimeoutSec</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>5min</span>

<span style=color:#000;font-weight:700>[Service]</span>
<span style=color:teal>User</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>nobody</span>
<span style=color:teal>ExecStart</span><span style=color:#000;font-weight:700>=</span><span style=color:#d14>/usr/bin/python /path/to/script.py</span>
</code></pre></div><p>In your python code, do the following</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>systemd_socket_response</span>():
    <span style=color:#d14>&#34;&#34;&#34;
</span><span style=color:#d14>    Accepts every connection of the listen socket provided by systemd, send the
</span><span style=color:#d14>    HTTP Response &#39;OK&#39; back.
</span><span style=color:#d14>    &#34;&#34;&#34;</span>
    <span style=color:#000;font-weight:700>try</span>:
        <span style=color:#000;font-weight:700>from</span> <span style=color:#555>systemd.daemon</span> <span style=color:#000;font-weight:700>import</span> listen_fds;
        fds <span style=color:#000;font-weight:700>=</span> listen_fds()
    <span style=color:#000;font-weight:700>except</span> <span style=color:#900;font-weight:700>ImportError</span>:
        fds <span style=color:#000;font-weight:700>=</span> [<span style=color:#099>3</span>]

    <span style=color:#000;font-weight:700>for</span> fd <span style=color:#000;font-weight:700>in</span> fds:
        <span style=color:#000;font-weight:700>import</span> <span style=color:#555>socket</span>
        sock <span style=color:#000;font-weight:700>=</span> socket<span style=color:#000;font-weight:700>.</span>fromfd(fd, socket<span style=color:#000;font-weight:700>.</span>AF_INET, socket<span style=color:#000;font-weight:700>.</span>SOCK_STREAM)
        sock<span style=color:#000;font-weight:700>.</span>settimeout(<span style=color:#099>0</span>)

        <span style=color:#000;font-weight:700>try</span>:
            <span style=color:#000;font-weight:700>while</span> <span style=color:#999>True</span>:
              conn, addr <span style=color:#000;font-weight:700>=</span> sock<span style=color:#000;font-weight:700>.</span>accept()
              conn<span style=color:#000;font-weight:700>.</span>sendall(<span style=color:#d14>b</span><span style=color:#d14>&#34;HTTP/1.1 200 OK</span><span style=color:#d14>\r\n</span><span style=color:#d14>Content-Type: text/plain</span><span style=color:#d14>\r\n</span><span style=color:#d14>Content-Length: 3</span><span style=color:#d14>\r\n\r\n</span><span style=color:#d14>OK</span><span style=color:#d14>\n</span><span style=color:#d14>&#34;</span>)
        <span style=color:#000;font-weight:700>except</span> socket<span style=color:#000;font-weight:700>.</span>timeout:
            <span style=color:#000;font-weight:700>pass</span>
        <span style=color:#000;font-weight:700>except</span> <span style=color:#900;font-weight:700>OSError</span> <span style=color:#000;font-weight:700>as</span> e:
            <span style=color:#998;font-style:italic># Connection closed again? Don&#39;t care, we just do our job.</span>
            <span style=color:#000;font-weight:700>print</span>(e)

<span style=color:#000;font-weight:700>if</span> __name__ <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;__main__&#34;</span>:
   <span style=color:#000;font-weight:700>if</span> os<span style=color:#000;font-weight:700>.</span>environ<span style=color:#000;font-weight:700>.</span>get(<span style=color:#d14>&#34;LISTEN_FDS&#34;</span>, <span style=color:#999>None</span>) <span style=color:#000;font-weight:700>!=</span> <span style=color:#999>None</span>:
        systemd_socket_response()
   <span style=color:#998;font-style:italic># here your own code begins</span>
   do_work()
</code></pre></div><p>This still lacks of authentication and does not take any arguments.
You could protect this port using a frontend webserver with http authentication,
or you pass the listen socket to an python http server, which add some token
passed authentication. Systemd will ensure, that your service will not run more
than once at the time.</p></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"mic92"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer>© 2021 Jörg Thalheim</footer></body></html>