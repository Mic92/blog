<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.79.1"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta property="og:title" content="Deploykit 1.0: A Python library for parallel deployment and maintaince task over ssh and locally"><meta property="og:title" content="Deploykit 1.0: A Python library for parallel deployment and maintaince task over ssh and locally"><meta property="og:description" content="When I started working on a growing fleet of NixOS machines, I eventually gained the need for running automating smaller maintenance tasks in parallel on a number of machines. I found a bunch of tools that seemed to fit the bill: ansible, fabric, .
While ansible seemed like the closest to my feature set it had a slow startup and a lot of unneccessary features, since NixOS already covers most of the configuration management part."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thalheim.io/2022/01/30/deploykit-1.0-a-python-library-for-parallel-deployment-and-maintaince-task-over-ssh-and-locally/"><meta property="article:published_time" content="2022-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Deploykit 1.0: A Python library for parallel deployment and maintaince task over ssh and locally"><meta name=twitter:description content="When I started working on a growing fleet of NixOS machines, I eventually gained the need for running automating smaller maintenance tasks in parallel on a number of machines. I found a bunch of tools that seemed to fit the bill: ansible, fabric, .
While ansible seemed like the closest to my feature set it had a slow startup and a lot of unneccessary features, since NixOS already covers most of the configuration management part."><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><title>Deploykit 1.0: A Python library for parallel deployment and maintaince task over ssh and locally | ~/git/blog</title><script data-goatcounter=https://goatcounter.thalheim.io/count async src=https://goatcounter.thalheim.io/count.js></script></head><body><header><div id=titletext><h2 id=title><a href=https://blog.thalheim.io/>~/git/blog</a></h2></div><div id=title-description><p id=subtitle>My brain-dump of random code/configuration.</p><div id=social><nav><ul><li><a href=/index.xml><i title=RSS class="icons fas fa-rss"></i></a></li><li><a href=https://github.com/Mic92/blog><i title=Github class="icons fab fa-github"></i></a></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>All Posts</a></li><li><a href=/categories>Categories</a></li></ul></nav></div></header><main><div class=post><div class=author></div><div class=post-header><div class=meta><div class=date><span class=day>30</span>
<span class=rest>Jan 2022</span></div></div><div class=matter><h1 class=title>Deploykit 1.0: A Python library for parallel deployment and maintaince task over ssh and locally</h1></div></div><div class=markdown><p>When I started working on a growing fleet of NixOS machines, I eventually gained
the need for running automating smaller maintenance tasks in parallel on a
number of machines. I found a bunch of tools that seemed to fit the bill:
ansible, fabric, .</p><p>While ansible seemed like the closest to my feature set it had a slow startup
and a lot of unneccessary features, since NixOS already covers most of the
configuration management part. Also it would captures the output of my remote
processes until they finish, while quite often when deploying NixOS machines I
rather prefer to get output as quickly as possible to see if something goes
wrong during system activation. Another limitation in most of these tools I
found, that they do not allow to run local commands in parallel. I.e. for my
nixos machines, I often upload the nixos configuration with rsync in order to
activate it on the remote machine.</p><p>After fighting against limitations of the existing tools for a while, I decided
to just write a simple python wrapper around ssh that spawns a number of thread.
For a long time this simple wrapper was just copied into every project where I
needed to deploy nixos machines.</p><p>With each new project the code also matured to the point where I had give it its
own repository, so that I can manage these modifications in central place.
<a href=https://github.com/numtide/deploykit target=_blank>Deploykit</a> was born.</p><p>Here is a simple example on what its API, looks like</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#000;font-weight:700>from</span> <span style=color:#555>deploykit</span> <span style=color:#000;font-weight:700>import</span> parse_hosts
<span style=color:#000;font-weight:700>import</span> <span style=color:#555>subprocess</span>

hosts <span style=color:#000;font-weight:700>=</span> parse_hosts(<span style=color:#d14>&#34;server1,server2,server3&#34;</span>)
runs <span style=color:#000;font-weight:700>=</span> hosts<span style=color:#000;font-weight:700>.</span>run(<span style=color:#d14>&#34;uptime&#34;</span>, stdout<span style=color:#000;font-weight:700>=</span>subprocess<span style=color:#000;font-weight:700>.</span>PIPE)
<span style=color:#000;font-weight:700>for</span> r <span style=color:#000;font-weight:700>in</span> runs:
    <span style=color:#000;font-weight:700>print</span>(f<span style=color:#d14>&#34;The uptime of {r.host.hostname} is {r.result.stdout}&#34;</span>)
</code></pre></div><p>I often use <code>deploykit</code> in combination with <a href>pyinvoke</a>. Which gives me a
simple commandline to run these tasks:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>inv reboot --hosts somehost
</code></pre></div><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#000;font-weight:700>from</span> <span style=color:#555>invoke</span> <span style=color:#000;font-weight:700>import</span> task
<span style=color:#000;font-weight:700>from</span> <span style=color:#555>deploykit</span> <span style=color:#000;font-weight:700>import</span> DeployHost, DeployGroup
<span style=color:#000;font-weight:700>import</span> <span style=color:#555>subprocess</span>

<span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>wait_for_host</span>(host: <span style=color:#0086b3>str</span>, shutdown: <span style=color:#0086b3>bool</span> <span style=color:#000;font-weight:700>=</span> <span style=color:#999>False</span>) <span style=color:#000;font-weight:700>-&gt;</span> <span style=color:#999>None</span>:
    <span style=color:#000;font-weight:700>import</span> <span style=color:#555>socket</span><span style=color:#000;font-weight:700>,</span> <span style=color:#555>time</span>

    <span style=color:#998;font-style:italic># Ping until the host is no longer reachable on shutdown and up when booting.</span>
    <span style=color:#000;font-weight:700>while</span> <span style=color:#999>True</span>:
        res <span style=color:#000;font-weight:700>=</span> subprocess<span style=color:#000;font-weight:700>.</span>run(
            [<span style=color:#d14>&#34;ping&#34;</span>, <span style=color:#d14>&#34;-q&#34;</span>, <span style=color:#d14>&#34;-c&#34;</span>, <span style=color:#d14>&#34;1&#34;</span>, <span style=color:#d14>&#34;-w&#34;</span>, <span style=color:#d14>&#34;2&#34;</span>, host], stdout<span style=color:#000;font-weight:700>=</span>subprocess<span style=color:#000;font-weight:700>.</span>DEVNULL
        )
        <span style=color:#000;font-weight:700>if</span> shutdown:
            <span style=color:#000;font-weight:700>if</span> res<span style=color:#000;font-weight:700>.</span>returncode <span style=color:#000;font-weight:700>==</span> <span style=color:#099>1</span>:
                <span style=color:#000;font-weight:700>break</span>
        <span style=color:#000;font-weight:700>else</span>:
            <span style=color:#000;font-weight:700>if</span> res<span style=color:#000;font-weight:700>.</span>returncode <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span>:
                <span style=color:#000;font-weight:700>break</span>
        time<span style=color:#000;font-weight:700>.</span>sleep(<span style=color:#099>1</span>)
        sys<span style=color:#000;font-weight:700>.</span>stdout<span style=color:#000;font-weight:700>.</span>write(<span style=color:#d14>&#34;.&#34;</span>)
        sys<span style=color:#000;font-weight:700>.</span>stdout<span style=color:#000;font-weight:700>.</span>flush()


<span style=color:#3c5d5d;font-weight:700>@task</span>
<span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>reboot</span>(c, hosts<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;&#34;</span>):
    <span style=color:#d14>&#34;&#34;&#34;
</span><span style=color:#d14>    Reboot hosts. example usage: inv reboot --hosts somehost
</span><span style=color:#d14>    &#34;&#34;&#34;</span>
    deploy_hosts <span style=color:#000;font-weight:700>=</span> [DeployHost(h, user<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;root&#34;</span>) <span style=color:#000;font-weight:700>for</span> h <span style=color:#000;font-weight:700>in</span> hosts<span style=color:#000;font-weight:700>.</span>split(<span style=color:#d14>&#34;,&#34;</span>)]
    <span style=color:#000;font-weight:700>for</span> h <span style=color:#000;font-weight:700>in</span> deploy_hosts:
        h<span style=color:#000;font-weight:700>.</span>run(<span style=color:#d14>&#34;reboot &amp;&#34;</span>)

        <span style=color:#000;font-weight:700>print</span>(f<span style=color:#d14>&#34;Wait for {h.host} to shutdown&#34;</span>, end<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;&#34;</span>)
        sys<span style=color:#000;font-weight:700>.</span>stdout<span style=color:#000;font-weight:700>.</span>flush()
        wait_for_host(h<span style=color:#000;font-weight:700>.</span>host, shutdown<span style=color:#000;font-weight:700>=</span><span style=color:#999>True</span>)
        <span style=color:#000;font-weight:700>print</span>(<span style=color:#d14>&#34;&#34;</span>)

        <span style=color:#000;font-weight:700>print</span>(f<span style=color:#d14>&#34;Wait for {h.host} to start&#34;</span>, end<span style=color:#000;font-weight:700>=</span><span style=color:#d14>&#34;&#34;</span>)
        sys<span style=color:#000;font-weight:700>.</span>stdout<span style=color:#000;font-weight:700>.</span>flush()
        wait_for_host(h<span style=color:#000;font-weight:700>.</span>host)
        <span style=color:#000;font-weight:700>print</span>(<span style=color:#d14>&#34;&#34;</span>)
</code></pre></div><p>Lastly my own personal use case is evolves mostly around deploying new
configuration to nixos machines. As you can see in this example, deploykit not
only allows to run a simple command in parallel on multiple hosts, but also
python functions, which allows for more flexibility i.e. by incorperating host
specific parameters into remote commands.</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>def deploy_nixos(hosts: List[DeployHost]) -&gt; None:
    &#34;&#34;&#34;
    Deploy to all hosts in parallel
    &#34;&#34;&#34;
    g = DeployGroup(hosts)

    def deploy(h: DeployHost) -&gt; None:
        h.run_local(
            f&#34;rsync -vaF --delete -e ssh . {h.user}@{h.host}:/etc/nixos&#34;
        )

        flake_path = &#34;/etc/nixos&#34;
        flake_attr = h.meta.get(&#34;flake_attr&#34;)
        if flake_attr:
            flake_path += &#34;#&#34; + flake_attr
        target_host = h.meta.get(&#34;target_host&#34;, &#34;localhost&#34;)
        h.run(
            f&#34;nixos-rebuild switch --option accept-flake-config true --build-host localhost --target-host {target_host} --flake {flake_path}&#34;
        )

    g.run_function(deploy)

HOSTS = [
    &#34;host1&#34;,
    &#34;host2&#34;,
    # ....
]

@task
def deploy(c):
    &#34;&#34;&#34;
    Deploy to servers
    &#34;&#34;&#34;
    deploy_nixos([DeployHost(h, user=&#34;root&#34;) for h in HOSTS])
</code></pre></div><p>That&rsquo;s all for today. I consider my work deploykit finished. I consider its API
stable and only plan to add smaller bugfixes and features to it.</p><p>If you like to use <code>deploykit</code> in your project, either consider downloading the
library from pypi, or use the nix flakes if case you are using the nix package
manager.</p></div><div class=tags><div class=taxosfloating_left><p>Categories</p></div><div class=termsfloating_right><p><a href=/categories/devops/>devops</a>
<a href=/categories/python/>python</a>
<a href=/categories/ssh/>ssh</a></p></div><div class=clearit></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"mic92"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer>© 2021 Jörg Thalheim</footer></body></html>